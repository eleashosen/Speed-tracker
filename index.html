<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Speed Meter</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better mobile experience and font */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            margin: 0;
            padding: 1rem; /* Add some padding around the content */
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 400px; /* Max width for better readability on larger screens */
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            padding: 2rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .speed-display {
            font-size: 4.5rem; /* Very large font for speed */
            font-weight: bold;
            color: #63b3ed; /* Blue color for speed */
            line-height: 1;
            transition: color 0.1s ease-out; /* Smooth transition for color change */
        }
        .speed-display.flash {
            color: #a7f3d0; /* A brighter, contrasting color for the flash */
        }
        .unit {
            font-size: 1.5rem;
            color: #a0aec0; /* Gray color for unit */
        }
        .status-message {
            font-size: 1.1rem;
            color: #cbd5e0;
            min-height: 2rem; /* Reserve space to prevent layout shifts */
        }
        .info-box {
            background-color: #4a5568; /* Darker gray for info */
            padding: 1rem;
            border-radius: 0.75rem;
            font-size: 0.9rem;
            color: #cbd5e0;
            text-align: left;
        }
        /* Canvas specific styling */
        #speedometerCanvas {
            background-color: #2d3748; /* Match container background */
            border-radius: 1rem;
            margin-top: 1.5rem;
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-width: 300px; /* Limit max size for dial */
            align-self: center; /* Center the canvas within the flex container */
        }
        .clock-display {
            font-size: 2rem;
            font-weight: bold;
            color: #a0aec0; /* Gray color for clock */
            margin-top: 1rem;
        }
        .location-address {
            font-size: 1rem;
            color: #a0aec0;
            margin-bottom: 1rem;
            word-wrap: break-word; /* Ensure long addresses wrap */
        }

        /* Tab specific styles */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
            background-color: #4a5568;
            border-radius: 0.75rem;
            padding: 0.5rem;
        }
        .tab-button {
            flex: 1;
            padding: 0.75rem 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #cbd5e0;
            background-color: transparent;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .tab-button.active {
            background-color: #63b3ed; /* Blue for active tab */
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .tab-button:hover:not(.active) {
            background-color: #5a657a;
        }
        .tab-content {
            display: none; /* Hidden by default */
        }
        .tab-content.active {
            display: flex; /* Show active content */
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Destination input and display styles */
        .destination-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .destination-input-group input[type="text"] {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
            width: 100%;
            box-sizing: border-box; /* Include padding in width */
        }
        .destination-input-group input[type="text"]::placeholder {
            color: #a0aec0;
        }
        .destination-input-group button {
            padding: 0.75rem 1.25rem;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 0.5rem;
            cursor: pointer;
            background-color: #4299e1; /* Blue for action button */
            color: white;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .destination-input-group button:hover {
            background-color: #3182ce;
        }
        .destination-input-group button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .distance-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f6ad55; /* Orange color for distance */
            margin-top: 1rem;
            min-height: 1.5rem; /* Reserve space */
        }
        .destination-name-display {
            font-size: 0.9rem;
            color: #cbd5e0;
            min-height: 1.2rem;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-white mb-2">Speed Meter</h1>
        
        <!-- Tabs Navigation -->
        <div class="tabs">
            <button id="speedTabButton" class="tab-button active">Speed Meter</button>
            <button id="distanceTabButton" class="tab-button">Distance Calculator</button>
        </div>

        <!-- Location Address Display (common to both tabs) -->
        <div id="locationAddress" class="location-address">Fetching current location...</div>

        <!-- Speed Meter Tab Content -->
        <div id="speedMeterTabContent" class="tab-content active">
            <!-- Canvas for the speedometer dial -->
            <canvas id="speedometerCanvas" width="300" height="150"></canvas>

            <div class="speed-display-area">
                <div id="speed" class="speed-display">0.0</div>
                <div id="unit" class="unit">km/h</div>
            </div>

            <!-- Clock display -->
            <div id="clock" class="clock-display"></div>

            <p id="status" class="status-message">Starting speed tracking...</p>
        </div>

        <!-- Distance Calculator Tab Content -->
        <div id="distanceCalculatorTabContent" class="tab-content">
            <div class="destination-input-group">
                <input type="text" id="destinationInput" placeholder="Enter destination address">
                <button id="setDestinationButton">Set Destination</button>
                <div id="destinationNameDisplay" class="destination-name-display"></div>
                <div id="distanceDisplay" class="distance-display"></div>
            </div>
            <p id="distanceStatus" class="status-message">Enter a destination to calculate distance.</p>
        </div>

        <div class="info-box">
            <p><strong>Note:</strong> Speed accuracy depends on your device's GPS signal. This app works best outdoors.</p>
            <p>If speed shows 0.0, it might be due to no movement or weak GPS signal.</p>
            <p>Location names and distance are fetched using OpenStreetMap Nominatim API, which has usage policies. Excessive requests might lead to temporary blocking.</p>
            <p><strong>Geolocation Permissions:</strong> If you see "Geolocation has been disabled...", please ensure your browser/device grants location access to this page. This is often a browser security setting.</p>
        </div>
    </div>

    <script>
        // Get references to HTML elements
        const speedDisplay = document.getElementById('speed');
        const unitDisplay = document.getElementById('unit');
        const statusMessage = document.getElementById('status');
        const speedometerCanvas = document.getElementById('speedometerCanvas');
        const ctx = speedometerCanvas.getContext('2d');
        const clockDisplay = document.getElementById('clock');
        const locationAddressDisplay = document.getElementById('locationAddress');

        const speedTabButton = document.getElementById('speedTabButton');
        const distanceTabButton = document.getElementById('distanceTabButton');
        const speedMeterTabContent = document.getElementById('speedMeterTabContent');
        const distanceCalculatorTabContent = document.getElementById('distanceCalculatorTabContent');

        const destinationInput = document.getElementById('destinationInput');
        const setDestinationButton = document.getElementById('setDestinationButton');
        const destinationNameDisplay = document.getElementById('destinationNameDisplay');
        const distanceDisplay = document.getElementById('distanceDisplay');
        const distanceStatus = document.getElementById('distanceStatus');


        let watchId = null;
        const speedUnit = 'km/h';
        const maxSpeed = 120;

        let lastLocationFetchTime = 0;
        const LOCATION_FETCH_THROTTLE_MS = 5000; // Throttle for reverse geocoding

        let currentDisplayedSpeed = 0.0; // Store the currently displayed speed for comparison

        let destinationCoords = null; // Stores { lat, lon } of the destination
        let currentLatitude = null; // Store current latitude for distance calculation
        let currentLongitude = null; // Store current longitude for distance calculation

        /**
         * Converts meters per second to kilometers per hour.
         * @param {number} mps - Speed in meters per second.
         * @returns {number} Speed in kilometers per hour.
         */
        function convertMpsToKmh(mps) {
            return mps * 3.6;
        }

        /**
         * Converts meters per second to miles per hour.
         * @param {number} mps - Speed in meters per second.
         * @returns {number} Speed in miles per hour.
         */
        function convertMpsToMph(mps) {
            return mps * 2.23694;
        }

        /**
         * Draws the speedometer dial, markings, and needle.
         * @param {number} currentSpeed - The current speed to display on the dial.
         */
        function drawSpeedometer(currentSpeed) {
            // Clear the canvas
            ctx.clearRect(0, 0, speedometerCanvas.width, speedometerCanvas.height);

            const centerX = speedometerCanvas.width / 2;
            const centerY = speedometerCanvas.height; // Base of the semi-circle
            const radius = speedometerCanvas.width / 2 - 10; // Slightly smaller than half width for padding

            // Draw the outer arc (speedometer background)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 2 * Math.PI, false); // Half circle from 180 to 360 degrees
            ctx.lineWidth = 20;
            ctx.strokeStyle = '#4a5568'; // Darker gray for the track
            ctx.stroke();

            // Draw speed markings and labels
            ctx.font = '14px Inter';
            ctx.fillStyle = '#cbd5e0'; // Light gray for text
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i <= maxSpeed; i += 20) {
                const angle = Math.PI + (i / maxSpeed) * Math.PI; // Map speed to angle (180 to 360 degrees)
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                // Draw tick marks
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#cbd5e0';
                ctx.moveTo(centerX + (radius - 10) * Math.cos(angle), centerY + (radius - 10) * Math.sin(angle));
                ctx.lineTo(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
                ctx.stroke();

                // Draw labels
                ctx.fillText(i.toString(), centerX + (radius - 25) * Math.cos(angle), centerY + (radius - 25) * Math.sin(angle));
            }

            // Draw the needle
            ctx.save(); // Save the current canvas state
            ctx.translate(centerX, centerY); // Move origin to center of the dial

            // Calculate needle angle based on current speed
            let needleAngle = Math.PI + (Math.min(currentSpeed, maxSpeed) / maxSpeed) * Math.PI;

            ctx.rotate(needleAngle); // Rotate to the calculated angle

            ctx.beginPath();
            ctx.moveTo(-5, 0); // Base of the needle
            ctx.lineTo(5, 0);
            ctx.lineTo(0, -radius + 15); // Tip of the needle
            ctx.closePath();
            ctx.fillStyle = '#f56565'; // Red color for the needle
            ctx.fill();

            // Draw the central pivot point
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#63b3ed'; // Blue for pivot
            ctx.fill();

            ctx.restore(); // Restore the canvas state
        }

        /**
         * Fetches the location name (address) using a reverse geocoding API.
         * @param {number} latitude - The latitude of the location.
         * @param {number} longitude - The longitude of the location.
         */
        async function fetchLocationName(latitude, longitude) {
            const currentTime = Date.now();
            if (currentTime - lastLocationFetchTime < LOCATION_FETCH_THROTTLE_MS) {
                // Too soon to fetch again, display current coordinates as a temporary fallback
                if (!locationAddressDisplay.textContent.includes("Throttled") && !locationAddressDisplay.textContent.includes("Location access denied")) {
                    locationAddressDisplay.textContent = `Lat: ${latitude.toFixed(5)}, Lon: ${longitude.toFixed(5)} (Throttled)`;
                }
                return;
            }

            lastLocationFetchTime = currentTime; // Update last fetch time

            locationAddressDisplay.textContent = 'Resolving current address...';
            try {
                // OpenStreetMap Nominatim API for reverse geocoding
                const apiUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`;
                const response = await fetch(apiUrl);
                const data = await response.json();

                if (data && data.display_name) {
                    locationAddressDisplay.textContent = data.display_name;
                } else {
                    locationAddressDisplay.textContent = `Lat: ${latitude.toFixed(5)}, Lon: ${longitude.toFixed(5)} (Address not found)`;
                }
            } catch (error) {
                console.error('Error fetching current location name:', error);
                locationAddressDisplay.textContent = `Lat: ${latitude.toFixed(5)}, Lon: ${longitude.toFixed(5)} (Failed to get address)`;
            }
        }

        /**
         * Calculates the distance between two geographical points using the Haversine formula.
         * @param {number} lat1 - Latitude of point 1 (in degrees).
         * @param {number} lon1 - Longitude of point 1 (in degrees).
         * @param {number} lat2 - Latitude of point 2 (in degrees).
         * @param {number} lon2 - Longitude of point 2 (in degrees).
         * @returns {number} Distance in kilometers.
         */
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c; // Distance in kilometers
            return distance;
        }

        /**
         * Geocodes an address and sets it as the destination.
         * @param {string} address - The address string to geocode.
         */
        async function geocodeAddress(address) {
            if (!address.trim()) {
                distanceDisplay.textContent = ''; // Clear previous distance
                destinationNameDisplay.textContent = 'Please enter a destination address.';
                distanceStatus.textContent = 'Please enter a destination address.';
                destinationCoords = null;
                return;
            }

            distanceStatus.textContent = 'Finding destination...';
            destinationNameDisplay.textContent = ''; // Clear previous destination name
            distanceDisplay.textContent = ''; // Clear previous distance

            try {
                const apiUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`; // Limit to 1 result
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    destinationCoords = {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon)
                    };
                    destinationNameDisplay.textContent = `Destination: ${data[0].display_name}`;
                    distanceStatus.textContent = 'Destination set. Calculating distance...';
                    // Trigger an immediate location update to calculate distance
                    if (currentLatitude !== null && currentLongitude !== null) {
                        const dist = calculateDistance(currentLatitude, currentLongitude, destinationCoords.lat, destinationCoords.lon);
                        distanceDisplay.textContent = `${dist.toFixed(2)} km`;
                    } else {
                        distanceDisplay.textContent = 'Waiting for current location...';
                    }
                } else {
                    destinationNameDisplay.textContent = '';
                    distanceDisplay.textContent = '';
                    distanceStatus.textContent = 'Destination not found. Please try a different address.';
                    destinationCoords = null;
                }
            } catch (error) {
                console.error('Error geocoding destination address:', error);
                destinationNameDisplay.textContent = '';
                distanceDisplay.textContent = '';
                distanceStatus.textContent = `Failed to find destination: Network or CORS issue.`;
                destinationCoords = null;
            }
        }

        /**
         * Success callback for geolocation.
         * Updates the speed display, speedometer dial, and distance.
         * @param {GeolocationPosition} position - The GeolocationPosition object.
         */
        function successCallback(position) {
            const speedMps = position.coords.speed; // Speed in meters per second
            currentLatitude = position.coords.latitude; // Update global currentLatitude
            currentLongitude = position.coords.longitude; // Update global currentLongitude

            let displaySpeed;
            if (speedUnit === 'km/h') {
                displaySpeed = convertMpsToKmh(speedMps);
            } else {
                displaySpeed = convertMpsToMph(speedMps);
            }

            const newSpeed = parseFloat(displaySpeed.toFixed(1)); // Get the new speed as a number, rounded

            // Apply the new condition: Don't display speed if less than 1 km/h
            if (newSpeed < 1.0) {
                if (currentDisplayedSpeed !== 0.0) { // Only update if it's changing to 0
                    speedDisplay.textContent = '0.0';
                    speedDisplay.classList.add('flash');
                    setTimeout(() => speedDisplay.classList.remove('flash'), 100);
                    currentDisplayedSpeed = 0.0;
                }
                statusMessage.textContent = 'GPS signal weak or no movement detected.';
                drawSpeedometer(0); // Ensure needle is at 0
            } else if (speedMps === null || speedMps < 0 || isNaN(newSpeed)) {
                // Existing condition for invalid speed data
                if (currentDisplayedSpeed !== 0.0) {
                    speedDisplay.textContent = '0.0';
                    speedDisplay.classList.add('flash');
                    setTimeout(() => speedDisplay.classList.remove('flash'), 100);
                    currentDisplayedSpeed = 0.0;
                }
                statusMessage.textContent = 'GPS signal weak or no movement detected.';
                drawSpeedometer(0);
            } else {
                // Display actual speed if >= 1 km/h and valid
                if (currentDisplayedSpeed !== newSpeed) {
                    speedDisplay.textContent = newSpeed.toFixed(1);
                    speedDisplay.classList.add('flash');
                    setTimeout(() => speedDisplay.classList.remove('flash'), 100);
                    currentDisplayedSpeed = newSpeed;
                }
                statusMessage.textContent = 'Tracking speed...';
                drawSpeedometer(newSpeed);
            }
            unitDisplay.textContent = speedUnit;

            // Fetch and display current location name, respecting the throttle
            fetchLocationName(currentLatitude, currentLongitude);

            // Calculate and display distance if a destination is set and on the distance tab
            if (distanceCalculatorTabContent.classList.contains('active') && destinationCoords) {
                const dist = calculateDistance(
                    currentLatitude, currentLongitude,
                    destinationCoords.lat, destinationCoords.lon
                );
                distanceDisplay.textContent = `${dist.toFixed(2)} km`;
                distanceStatus.textContent = 'Distance updated.';
            } else if (distanceCalculatorTabContent.classList.contains('active') && !destinationCoords) {
                 distanceStatus.textContent = 'Enter a destination to calculate distance.';
            }
        }

        /**
         * Error callback for geolocation.
         * Displays an error message to the user.
         * @param {GeolocationPositionError} error - The GeolocationPositionError object.
         */
        function errorCallback(error) {
            let errorMessage = '';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = "Permission denied: Please allow location access for this app to work.";
                    locationAddressDisplay.textContent = 'Location access denied.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage = "Position unavailable: Your location could not be determined.";
                    locationAddressDisplay.textContent = 'Location unavailable.';
                    break;
                case error.TIMEOUT:
                    errorMessage = "Timeout: Could not retrieve location within the allowed time.";
                    locationAddressDisplay.textContent = 'Location timeout.';
                    break;
                default:
                    errorMessage = "An unknown error occurred while getting your location.";
                    locationAddressDisplay.textContent = 'Location error.';
                    break;
            }
            speedDisplay.textContent = 'N/A';
            statusMessage.textContent = errorMessage;
            console.error('Geolocation error:', error.code, error.message, error);
            drawSpeedometer(0);
            // Update distance status if on distance tab
            if (distanceCalculatorTabContent.classList.contains('active')) {
                distanceStatus.textContent = 'Cannot calculate distance without current location.';
                distanceDisplay.textContent = '';
            }
        }

        /**
         * Starts tracking the user's speed.
         * This function is now called automatically on page load.
         */
        function startTracking() {
            if (navigator.geolocation) {
                statusMessage.textContent = 'Attempting to get location...';
                locationAddressDisplay.textContent = 'Getting precise current location...';
                const options = {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                };
                watchId = navigator.geolocation.watchPosition(successCallback, errorCallback, options);
            } else {
                statusMessage.textContent = 'Geolocation is not supported by your browser.';
                locationAddressDisplay.textContent = 'Geolocation not supported.';
                // Update distance status if on distance tab
                if (distanceCalculatorTabContent.classList.contains('active')) {
                    distanceStatus.textContent = 'Geolocation not supported.';
                    destinationNameDisplay.textContent = '';
                    distanceDisplay.textContent = '';
                }
            }
        }

        /**
         * Function to update the digital clock display.
         */
        function updateClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            clockDisplay.textContent = `${hours}:${minutes}:${seconds}`;
        }

        /**
         * Function to resize canvas and redraw speedometer.
         */
        function resizeCanvas() {
            const computedStyle = getComputedStyle(speedometerCanvas);
            const parentWidth = parseFloat(computedStyle.width);
            speedometerCanvas.width = parentWidth;
            speedometerCanvas.height = parentWidth / 2;
            const currentSpeed = parseFloat(speedDisplay.textContent);
            if (!isNaN(currentSpeed)) {
                drawSpeedometer(currentSpeed);
            } else {
                drawSpeedometer(0);
            }
        }

        /**
         * Switches the active tab.
         * @param {string} tabName - The ID of the tab content to activate ('speedMeterTabContent' or 'distanceCalculatorTabContent').
         */
        function switchTab(tabName) {
            // Deactivate all tab buttons and content
            speedTabButton.classList.remove('active');
            distanceTabButton.classList.remove('active');
            speedMeterTabContent.classList.remove('active');
            distanceCalculatorTabContent.classList.remove('active');

            // Activate the selected tab button and content
            if (tabName === 'speedMeterTabContent') {
                speedTabButton.classList.add('active');
                speedMeterTabContent.classList.add('active');
                // Ensure speed-related messages are visible
                statusMessage.style.display = 'block';
                distanceStatus.style.display = 'none';
            } else if (tabName === 'distanceCalculatorTabContent') {
                distanceTabButton.classList.add('active');
                distanceCalculatorTabContent.classList.add('active');
                // Ensure distance-related messages are visible
                statusMessage.style.display = 'none';
                distanceStatus.style.display = 'block';
            }
            resizeCanvas(); // Recalculate canvas size if needed after tab switch
        }

        // Event listeners for tab buttons
        speedTabButton.addEventListener('click', () => switchTab('speedMeterTabContent'));
        distanceTabButton.addEventListener('click', () => switchTab('distanceCalculatorTabContent'));

        // Event listener for the Set Destination button
        setDestinationButton.addEventListener('click', () => {
            geocodeAddress(destinationInput.value);
        });

        // Initial setup on window load
        window.onload = function() {
            if (!navigator.geolocation) {
                statusMessage.textContent = 'Geolocation is not supported by your browser.';
                locationAddressDisplay.textContent = 'Geolocation not supported.';
                distanceStatus.textContent = 'Geolocation not supported.'; // Also update distance tab status
            }
            resizeCanvas();
            startTracking();
            setInterval(updateClock, 1000);
            updateClock();
            switchTab('speedMeterTabContent'); // Default to Speed Meter tab
        };

        // Redraw speedometer on window resize
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
