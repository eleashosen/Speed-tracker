<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Speed Meter</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better mobile experience and font */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000000; /* Solid black background */
            color: #e2e8f0; /* Light text */
            margin: 0;
            padding: 1rem; /* Add some padding around the content */
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 400px; /* Max width for better readability on larger screens */
            background-color: #000000; /* Solid black for container to match dial */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5); /* Stronger shadow for black theme */
            padding: 2rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .speed-display {
            font-size: 4.5rem; /* Very large font for speed */
            font-weight: bold;
            color: #ff8c00; /* Orange/Red color for speed, mimicking segmented display */
            line-height: 1;
            transition: color 0.1s ease-out; /* Smooth transition for color change */
            /* Attempt to mimic segmented font style */
            font-family: 'Digital-7', monospace; /* Placeholder, true digital font requires import */
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.7); /* Glow effect */
        }
        /* Fallback for Digital-7 font if not loaded */
        @font-face {
            font-family: 'Digital-7';
            src: url('https://raw.githubusercontent.com/spleennoon/Digital-7/master/digital-7.ttf') format('truetype');
            /* Note: Direct linking to TTF from GitHub raw might have CORS issues or be unreliable.
               For production, host this font yourself or use a service like Google Fonts if available.
               Using monospace as a fallback. */
        }

        .speed-display.flash {
            color: #ffddaa; /* Brighter flash color */
        }
        .unit {
            font-size: 1.5rem;
            color: #ffffff; /* White for unit */
            font-family: 'Digital-7', monospace; /* Mimic segmented font */
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); /* Subtle glow */
        }
        .status-message {
            font-size: 1.1rem;
            color: #cbd5e0;
            min-height: 2rem; /* Reserve space to prevent layout shifts */
        }
        .info-box {
            background-color: #1a1a1a; /* Darker gray for info, but still very dark */
            padding: 1rem;
            border-radius: 0.75rem;
            font-size: 0.9rem;
            color: #a0aec0; /* Slightly muted text for info */
            text-align: left;
            margin-top: 1.5rem; /* Add margin above info box */
        }
        /* Canvas specific styling */
        #speedometerCanvas {
            background-color: #000000; /* Match container background */
            border-radius: 1rem;
            margin-top: 1.5rem;
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-width: 300px; /* Limit max size for dial */
            align-self: center; /* Center the canvas within the flex container */
        }
        .clock-display {
            font-size: 2rem;
            font-weight: bold;
            color: #a0aec0; /* Gray color for clock */
            margin-top: 1rem;
            font-family: 'Digital-7', monospace; /* Mimic segmented font */
            text-shadow: 0 0 8px rgba(160, 174, 192, 0.5); /* Glow effect */
        }
        .location-address {
            font-size: 1rem;
            color: #a0aec0;
            margin-bottom: 1rem;
            word-wrap: break-word; /* Ensure long addresses wrap */
        }

        /* Tab specific styles */
        .tabs {
            display: flex;
            justify-content: center;
            margin-top: 1.5rem; /* Add margin above tabs when at bottom */
            background-color: #1a1a1a; /* Darker background for tabs */
            border-radius: 0.75rem;
            padding: 0.5rem;
            width: 100%; /* Ensure tabs span full width */
        }
        .tab-button {
            flex: 1;
            padding: 0.75rem 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #cbd5e0;
            background-color: transparent;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .tab-button.active {
            background-color: #007bff; /* A distinct blue for active tab */
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .tab-button:hover:not(.active) {
            background-color: #2a2a2a;
        }
        .tab-content {
            display: none; /* Hidden by default */
            width: 100%; /* Ensure content takes full width */
        }
        .tab-content.active {
            display: flex; /* Show active content */
            flex-direction: column;
            gap: 1.5rem;
        }

        /* GPS Indicator Styling */
        .gps-indicator {
            font-size: 1.8rem; /* Size for GPS text */
            font-weight: bold;
            color: #00ffff; /* Cyan color for GPS */
            font-family: 'Digital-7', monospace; /* Mimic segmented font */
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7); /* Glow effect */
            margin-top: 1rem; /* Space below speed/unit */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-white mb-2">Speed Meter</h1>
        
        <!-- Location Address Display (common to both tabs) -->
        <div id="locationAddress" class="location-address">Fetching current location...</div>

        <!-- Speed Meter Tab Content -->
        <div id="speedMeterTabContent" class="tab-content active">
            <!-- Canvas for the speedometer dial -->
            <canvas id="speedometerCanvas" width="300" height="150"></canvas>

            <div class="speed-display-area">
                <div id="speed" class="speed-display">0.0</div>
                <div id="unit" class="unit">MPH</div>
            </div>

            <!-- GPS Indicator -->
            <div id="gpsIndicator" class="gps-indicator">GPS</div>

            <!-- Clock display -->
            <div id="clock" class="clock-display"></div>

            <p id="status" class="status-message">Starting speed tracking...</p>
        </div>

        <!-- Distance Calculator Tab Content -->
        <div id="distanceCalculatorTabContent" class="tab-content">
            <div class="destination-input-group">
                <input type="text" id="destinationInput" placeholder="Enter destination address">
                <button id="setDestinationButton">Set Destination</button>
                <div id="destinationNameDisplay" class="destination-name-display"></div>
                <div id="distanceDisplay" class="distance-display"></div>
            </div>
            <p id="distanceStatus" class="status-message">Enter a destination to calculate distance.</p>
        </div>

        <!-- Tabs Navigation -->
        <div class="tabs">
            <button id="speedTabButton" class="tab-button active">Speed Meter</button>
            <button id="distanceTabButton" class="tab-button">Distance Calculator</button>
        </div>

        <div class="info-box">
            <p><strong>Note:</strong> Speed accuracy depends on your device's GPS signal. This app works best outdoors.</p>
            <p>If speed shows 0.0, it might be due to no movement or weak GPS signal.</p>
            <p>Location names and distance are fetched using OpenStreetMap Nominatim API, which has usage policies. Excessive requests might lead to temporary blocking.</p>
            <p><strong>Geolocation Permissions:</strong> If you see "Geolocation has been disabled...", please ensure your browser/device grants location access to this page. This is often a browser security setting.</p>
        </div>
    </div>

    <script>
        // Get references to HTML elements
        const speedDisplay = document.getElementById('speed');
        const unitDisplay = document.getElementById('unit');
        const statusMessage = document.getElementById('status');
        const speedometerCanvas = document.getElementById('speedometerCanvas');
        const ctx = speedometerCanvas.getContext('2d');
        const clockDisplay = document.getElementById('clock');
        const locationAddressDisplay = document.getElementById('locationAddress');
        const gpsIndicator = document.getElementById('gpsIndicator'); // New GPS indicator element

        const speedTabButton = document.getElementById('speedTabButton');
        const distanceTabButton = document.getElementById('distanceTabButton');
        const speedMeterTabContent = document.getElementById('speedMeterTabContent');
        const distanceCalculatorTabContent = document.getElementById('distanceCalculatorTabContent');

        const destinationInput = document.getElementById('destinationInput');
        const setDestinationButton = document.getElementById('setDestinationButton');
        const destinationNameDisplay = document.getElementById('destinationNameDisplay');
        const distanceDisplay = document.getElementById('distanceDisplay');
        const distanceStatus = document.getElementById('distanceStatus');


        let watchId = null;
        const speedUnit = 'mph'; // Changed to MPH as per image
        const maxSpeed = 140; // Changed to 140 MPH as per image

        let lastLocationFetchTime = 0;
        const LOCATION_FETCH_THROTTLE_MS = 5000; // Throttle for reverse geocoding

        let currentDisplayedSpeed = 0.0; // Store the currently displayed speed for comparison

        let destinationCoords = null; // Stores { lat, lon } of the destination
        let currentLatitude = null; // Store current latitude for distance calculation
        let currentLongitude = null; // Store current longitude for distance calculation

        /**
         * Converts meters per second to kilometers per hour.
         * @param {number} mps - Speed in meters per second.
         * @returns {number} Speed in kilometers per hour.
         */
        function convertMpsToKmh(mps) {
            return mps * 3.6;
        }

        /**
         * Converts meters per second to miles per hour.
         * @param {number} mps - Speed in meters per second.
         * @returns {number} Speed in miles per hour.
         */
        function convertMpsToMph(mps) {
            return mps * 2.23694;
        }

        /**
         * Draws the speedometer dial, markings, and needle.
         * @param {number} currentSpeed - The current speed to display on the dial.
         */
        function drawSpeedometer(currentSpeed) {
            // Clear the canvas
            ctx.clearRect(0, 0, speedometerCanvas.width, speedometerCanvas.height);

            const centerX = speedometerCanvas.width / 2;
            const centerY = speedometerCanvas.height; // Base of the semi-circle
            const radius = speedometerCanvas.width / 2 - 15; // Slightly smaller for thicker outer ring

            // Draw the outer gradient ring segments
            const startAngle = Math.PI; // 180 degrees
            const endAngle = 2 * Math.PI; // 360 degrees (full circle, but we draw half)

            const greenEnd = 60; // Up to 60 MPH
            const yellowEnd = 90; // Up to 90 MPH
            const orangeEnd = 110; // Up to 110 MPH
            // Red goes up to maxSpeed (140 MPH)

            const segmentWidth = 20; // Thickness of the colored ring

            // Function to draw a colored arc segment
            function drawArcSegment(startVal, endVal, color) {
                const segmentStartAngle = startAngle + (startVal / maxSpeed) * Math.PI;
                const segmentEndAngle = startAngle + (endVal / maxSpeed) * Math.PI;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, segmentStartAngle, segmentEndAngle, false);
                ctx.lineWidth = segmentWidth;
                ctx.strokeStyle = color;
                ctx.stroke();
            }

            // Draw colored segments
            drawArcSegment(0, greenEnd, '#00ff00'); // Green
            drawArcSegment(greenEnd, yellowEnd, '#ffff00'); // Yellow
            drawArcSegment(yellowEnd, orangeEnd, '#ff8c00'); // Orange
            drawArcSegment(orangeEnd, maxSpeed, '#ff0000'); // Red

            // Draw tick marks and labels
            ctx.font = '14px Inter'; // Keeping Inter for numbers, but could use Digital-7 if desired
            ctx.fillStyle = '#ffffff'; // White for numbers
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i <= maxSpeed; i += 10) { // Major ticks every 10 MPH
                const angle = startAngle + (i / maxSpeed) * Math.PI;
                const tickLength = (i % 20 === 0) ? 10 : 5; // Longer ticks for 20, 40, 60...
                const innerTickRadius = radius - segmentWidth / 2 - tickLength;
                const outerTickRadius = radius - segmentWidth / 2;

                // Draw tick marks
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#ffffff'; // White ticks
                ctx.moveTo(centerX + innerTickRadius * Math.cos(angle), centerY + innerTickRadius * Math.sin(angle));
                ctx.lineTo(centerX + outerTickRadius * Math.cos(angle), centerY + outerTickRadius * Math.sin(angle));
                ctx.stroke();

                // Draw labels for major ticks (every 20 MPH)
                if (i % 20 === 0) {
                    const labelRadius = radius - segmentWidth / 2 - 25; // Position labels further in
                    ctx.fillText(i.toString(), centerX + labelRadius * Math.cos(angle), centerY + labelRadius * Math.sin(angle));
                }
            }

            // Draw the needle
            ctx.save(); // Save the current canvas state
            ctx.translate(centerX, centerY); // Move origin to center of the dial

            // Calculate needle angle based on current speed
            let needleAngle = startAngle + (Math.min(currentSpeed, maxSpeed) / maxSpeed) * Math.PI;

            ctx.rotate(needleAngle); // Rotate to the calculated angle

            ctx.beginPath();
            ctx.moveTo(-3, 0); // Base of the needle (thinner)
            ctx.lineTo(3, 0);
            ctx.lineTo(0, -radius + 10); // Tip of the needle
            ctx.closePath();
            ctx.fillStyle = '#ff0000'; // Red color for the needle
            ctx.fill();

            // Draw the central pivot point
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, 2 * Math.PI); // Larger pivot
            ctx.fillStyle = '#ffffff'; // White pivot
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, 2 * Math.PI); // Smaller red center
            ctx.fillStyle = '#ff0000';
            ctx.fill();

            ctx.restore(); // Restore the canvas state
        }

        /**
         * Fetches the location name (address) using a reverse geocoding API.
         * @param {number} latitude - The latitude of the location.
         * @param {number} longitude - The longitude of the location.
         */
        async function fetchLocationName(latitude, longitude) {
            const currentTime = Date.now();
            if (currentTime - lastLocationFetchTime < LOCATION_FETCH_THROTTLE_MS) {
                // Too soon to fetch again, display current coordinates as a temporary fallback
                if (!locationAddressDisplay.textContent.includes("Throttled") && !locationAddressDisplay.textContent.includes("Location access denied")) {
                    locationAddressDisplay.textContent = `Lat: ${latitude.toFixed(5)}, Lon: ${longitude.toFixed(5)} (Throttled)`;
                }
                return;
            }

            lastLocationFetchTime = currentTime; // Update last fetch time

            locationAddressDisplay.textContent = 'Resolving current address...';
            try {
                // OpenStreetMap Nominatim API for reverse geocoding
                const apiUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`;
                const response = await fetch(apiUrl);
                const data = await response.json();

                if (data && data.display_name) {
                    locationAddressDisplay.textContent = data.display_name;
                } else {
                    locationAddressDisplay.textContent = `Lat: ${latitude.toFixed(5)}, Lon: ${longitude.toFixed(5)} (Address not found)`;
                }
            } catch (error) {
                console.error('Error fetching current location name:', error);
                locationAddressDisplay.textContent = `Lat: ${latitude.toFixed(5)}, Lon: ${longitude.toFixed(5)} (Failed to get address)`;
            }
        }

        /**
         * Calculates the distance between two geographical points using the Haversine formula.
         * @param {number} lat1 - Latitude of point 1 (in degrees).
         * @param {number} lon1 - Longitude of point 1 (in degrees).
         * @param {number} lat2 - Latitude of point 2 (in degrees).
         * @param {number} lon2 - Longitude of point 2 (in degrees).
         * @returns {number} Distance in kilometers.
         */
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c; // Distance in kilometers
            return distance;
        }

        /**
         * Geocodes an address and sets it as the destination.
         * @param {string} address - The address string to geocode.
         */
        async function geocodeAddress(address) {
            if (!address.trim()) {
                distanceDisplay.textContent = ''; // Clear previous distance
                destinationNameDisplay.textContent = 'Please enter a destination address.';
                distanceStatus.textContent = 'Please enter a destination address.';
                destinationCoords = null;
                return;
            }

            distanceStatus.textContent = 'Finding destination...';
            destinationNameDisplay.textContent = ''; // Clear previous destination name
            distanceDisplay.textContent = ''; // Clear previous distance

            try {
                const apiUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`; // Limit to 1 result
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    destinationCoords = {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon)
                    };
                    destinationNameDisplay.textContent = `Destination: ${data[0].display_name}`;
                    distanceStatus.textContent = 'Destination set. Calculating distance...';
                    // Trigger an immediate location update to calculate distance
                    if (currentLatitude !== null && currentLongitude !== null) {
                        const dist = calculateDistance(currentLatitude, currentLongitude, destinationCoords.lat, destinationCoords.lon);
                        distanceDisplay.textContent = `${dist.toFixed(2)} km`;
                    } else {
                        distanceDisplay.textContent = 'Waiting for current location...';
                    }
                } else {
                    destinationNameDisplay.textContent = '';
                    distanceDisplay.textContent = '';
                    distanceStatus.textContent = 'Destination not found. Please try a different address.';
                    destinationCoords = null;
                }
            } catch (error) {
                console.error('Error geocoding destination address:', error);
                destinationNameDisplay.textContent = '';
                distanceDisplay.textContent = '';
                distanceStatus.textContent = `Failed to find destination: Network or CORS issue.`;
                destinationCoords = null;
            }
        }

        /**
         * Success callback for geolocation.
         * Updates the speed display, speedometer dial, and distance.
         * @param {GeolocationPosition} position - The GeolocationPosition object.
         */
        function successCallback(position) {
            const speedMps = position.coords.speed; // Speed in meters per second
            currentLatitude = position.coords.latitude; // Update global currentLatitude
            currentLongitude = position.coords.longitude; // Update global currentLongitude

            let displaySpeed;
            if (speedUnit === 'km/h') { // This logic needs to be updated to MPH
                displaySpeed = convertMpsToKmh(speedMps);
            } else {
                displaySpeed = convertMpsToMph(speedMps); // Use MPH conversion
            }

            const newSpeed = parseFloat(displaySpeed.toFixed(1)); // Get the new speed as a number, rounded

            // Apply the new condition: Don't display speed if less than 1 km/h (now MPH)
            if (newSpeed < 1.0) {
                if (currentDisplayedSpeed !== 0.0) { // Only update if it's changing to 0
                    speedDisplay.textContent = '0.0';
                    speedDisplay.classList.add('flash');
                    setTimeout(() => speedDisplay.classList.remove('flash'), 100);
                    currentDisplayedSpeed = 0.0;
                }
                statusMessage.textContent = 'GPS signal weak or no movement detected.';
                drawSpeedometer(0); // Ensure needle is at 0
            } else if (speedMps === null || speedMps < 0 || isNaN(newSpeed)) {
                // Existing condition for invalid speed data
                if (currentDisplayedSpeed !== 0.0) {
                    speedDisplay.textContent = '0.0';
                    speedDisplay.classList.add('flash');
                    setTimeout(() => speedDisplay.classList.remove('flash'), 100);
                    currentDisplayedSpeed = 0.0;
                }
                statusMessage.textContent = 'GPS signal weak or no movement detected.';
                drawSpeedometer(0);
            } else {
                // Display actual speed if >= 1 km/h (now MPH) and valid
                if (currentDisplayedSpeed !== newSpeed) {
                    speedDisplay.textContent = newSpeed.toFixed(1);
                    speedDisplay.classList.add('flash');
                    setTimeout(() => speedDisplay.classList.remove('flash'), 100);
                    currentDisplayedSpeed = newSpeed;
                }
                statusMessage.textContent = 'Tracking speed...';
                drawSpeedometer(newSpeed);
            }
            unitDisplay.textContent = speedUnit.toUpperCase(); // Ensure unit is uppercase (MPH)

            // Fetch and display current location name, respecting the throttle
            fetchLocationName(currentLatitude, currentLongitude);

            // Update GPS indicator visibility based on signal
            if (speedMps !== null && speedMps >= 0) {
                gpsIndicator.style.visibility = 'visible';
            } else {
                gpsIndicator.style.visibility = 'hidden';
            }


            // Calculate and display distance if a destination is set and on the distance tab
            if (distanceCalculatorTabContent.classList.contains('active') && destinationCoords) {
                const dist = calculateDistance(
                    currentLatitude, currentLongitude,
                    destinationCoords.lat, destinationCoords.lon
                );
                distanceDisplay.textContent = `${dist.toFixed(2)} km`;
                distanceStatus.textContent = 'Distance updated.';
            } else if (distanceCalculatorTabContent.classList.contains('active') && !destinationCoords) {
                 distanceStatus.textContent = 'Enter a destination to calculate distance.';
                 distanceDisplay.textContent = ''; // Ensure distance is clear if no destination
                 destinationNameDisplay.textContent = ''; // Ensure destination name is clear
            }
        }

        /**
         * Error callback for geolocation.
         * Displays an error message to the user.
         * @param {GeolocationPositionError} error - The GeolocationPositionError object.
         */
        function errorCallback(error) {
            let errorMessage = '';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = "Permission denied: Please allow location access for this app to work.";
                    locationAddressDisplay.textContent = 'Location access denied.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage = "Position unavailable: Your location could not be determined.";
                    locationAddressDisplay.textContent = 'Location unavailable.';
                    break;
                case error.TIMEOUT:
                    errorMessage = "Timeout: Could not retrieve location within the allowed time.";
                    locationAddressDisplay.textContent = 'Location timeout.';
                    break;
                default:
                    errorMessage = "An unknown error occurred while getting your location.";
                    locationAddressDisplay.textContent = 'Location error.';
                    break;
            }
            speedDisplay.textContent = 'N/A';
            statusMessage.textContent = errorMessage;
            console.error('Geolocation error:', error.code, error.message, error);
            drawSpeedometer(0);
            gpsIndicator.style.visibility = 'hidden'; // Hide GPS indicator on error
            // Update distance status if on distance tab
            if (distanceCalculatorTabContent.classList.contains('active')) {
                distanceStatus.textContent = 'Cannot calculate distance without current location.';
                distanceDisplay.textContent = '';
            }
        }

        /**
         * Starts tracking the user's speed.
         * This function is now called automatically on page load.
         */
        function startTracking() {
            if (navigator.geolocation) {
                statusMessage.textContent = 'Attempting to get location...';
                locationAddressDisplay.textContent = 'Getting precise current location...';
                const options = {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                };
                watchId = navigator.geolocation.watchPosition(successCallback, errorCallback, options);
            } else {
                statusMessage.textContent = 'Geolocation is not supported by your browser.';
                locationAddressDisplay.textContent = 'Geolocation not supported.';
                gpsIndicator.style.visibility = 'hidden'; // Hide GPS indicator if not supported
                // Update distance status if on distance tab
                if (distanceCalculatorTabContent.classList.contains('active')) {
                    distanceStatus.textContent = 'Geolocation not supported.';
                    destinationNameDisplay.textContent = '';
                    distanceDisplay.textContent = '';
                }
            }
        }

        /**
         * Function to update the digital clock display.
         */
        function updateClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            clockDisplay.textContent = `${hours}:${minutes}:${seconds}`;
        }

        /**
         * Function to resize canvas and redraw speedometer.
         */
        function resizeCanvas() {
            const computedStyle = getComputedStyle(speedometerCanvas);
            const parentWidth = parseFloat(computedStyle.width);
            speedometerCanvas.width = parentWidth;
            speedometerCanvas.height = parentWidth / 2;
            const currentSpeed = parseFloat(speedDisplay.textContent);
            if (!isNaN(currentSpeed)) {
                drawSpeedometer(currentSpeed);
            } else {
                drawSpeedometer(0);
            }
        }

        /**
         * Switches the active tab.
         * @param {string} tabName - The ID of the tab content to activate ('speedMeterTabContent' or 'distanceCalculatorTabContent').
         */
        function switchTab(tabName) {
            // Deactivate all tab buttons and content
            speedTabButton.classList.remove('active');
            distanceTabButton.classList.remove('active');
            speedMeterTabContent.classList.remove('active');
            distanceCalculatorTabContent.classList.remove('active');

            // Hide all status messages initially
            statusMessage.style.display = 'none';
            distanceStatus.style.display = 'none';

            // Activate the selected tab button and content
            if (tabName === 'speedMeterTabContent') {
                speedTabButton.classList.add('active');
                speedMeterTabContent.classList.add('active');
                statusMessage.style.display = 'block'; // Show speed status
                // Clear distance-related displays when switching away from distance tab
                distanceDisplay.textContent = '';
                destinationNameDisplay.textContent = '';
                destinationInput.value = ''; // Clear destination input field
                destinationCoords = null; // Reset destination coordinates
                gpsIndicator.style.visibility = 'visible'; // Show GPS indicator on speed tab
            } else if (tabName === 'distanceCalculatorTabContent') {
                distanceTabButton.classList.add('active');
                distanceCalculatorTabContent.classList.add('active');
                distanceStatus.style.display = 'block'; // Show distance status
                gpsIndicator.style.visibility = 'hidden'; // Hide GPS indicator on distance tab

                // Set initial messages for distance tab if no destination is set
                if (!destinationCoords) {
                    distanceDisplay.textContent = '';
                    destinationNameDisplay.textContent = '';
                    distanceStatus.textContent = 'Enter a destination to calculate distance.';
                } else {
                    // If a destination is set, re-display its name and current distance
                    // Use destinationInput.value as a reliable source for the entered name
                    destinationNameDisplay.textContent = `Destination: ${destinationInput.value}`;
                    if (currentLatitude !== null && currentLongitude !== null) {
                        const dist = calculateDistance(currentLatitude, currentLongitude, destinationCoords.lat, destinationCoords.lon);
                        distanceDisplay.textContent = `${dist.toFixed(2)} km`;
                        distanceStatus.textContent = 'Distance updated.';
                    } else {
                        distanceDisplay.textContent = 'Waiting for current location...';
                        distanceStatus.textContent = 'Waiting for current location...';
                    }
                }
            }
            resizeCanvas(); // Recalculate canvas size if needed after tab switch
        }

        // Event listeners for tab buttons
        speedTabButton.addEventListener('click', () => switchTab('speedMeterTabContent'));
        distanceTabButton.addEventListener('click', () => switchTab('distanceCalculatorTabContent'));

        // Event listener for the Set Destination button
        setDestinationButton.addEventListener('click', () => {
            geocodeAddress(destinationInput.value);
        });

        // Initial setup on window load
        window.onload = function() {
            if (!navigator.geolocation) {
                statusMessage.textContent = 'Geolocation is not supported by your browser.';
                locationAddressDisplay.textContent = 'Geolocation not supported.';
                distanceStatus.textContent = 'Geolocation not supported.'; // Also update distance tab status
                gpsIndicator.style.visibility = 'hidden'; // Hide if geolocation not supported
            }
            resizeCanvas();
            startTracking();
            setInterval(updateClock, 1000);
            updateClock();
            switchTab('speedMeterTabContent'); // Default to Speed Meter tab
            // Initialize distance tab messages
            distanceDisplay.textContent = '';
            destinationNameDisplay.textContent = '';
            distanceStatus.textContent = 'Enter a destination to calculate distance.';
        };

        // Redraw speedometer on window resize
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
